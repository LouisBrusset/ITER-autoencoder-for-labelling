<!DOCTYPE html>
<html lang="fr">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autoencoder - Anomaly Detection</title>
    <link rel="stylesheet" href="styles/style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
    <div class="container">
        <header>
            <h1>Autoencoder - Anomaly Detection</h1>
            <nav class="navigation">
                <a href="#section-data" class="nav-link active">1. Data</a>
                <a href="#section-checking" class="nav-link">2. Checking</a>
                <a href="#section-training" class="nav-link">3. Training</a>
                <a href="#section-visualization" class="nav-link">4. Visualization</a>
                <a href="#section-classification" class="nav-link">5. Classification</a>
            </nav>
        </header>

        <!-- SECTION 1 : DATA -->
        <section id="section-data" class="section active">
            <h2>1. Data loading</h2>
            
            <div class="card">
                <h3>Upload a file</h3>
                <input type="file" id="fileUpload" accept=".csv,.npz">
                <button onclick="uploadData()" class="btn-primary">Upload</button>
                <div id="uploadStatus"></div>
            </div>
            
            <div class="card">
                <h3>or create synthetic data</h3>
                <div class="form-group">
                    <label>Number of samples:</label>
                    <input type="number" id="nSamples" value="1000" min="100" max="10000">
                </div>
                <div class="form-group">
                    <label>Data dimension:</label>
                    <input type="number" id="inputDim" value="20" min="5" max="100">
                </div>
                <div class="form-group">
                    <label>Number of anomalies:</label>
                    <input type="number" id="nAnomalies" value="50" min="0" max="200">
                </div>
                <button onclick="createSyntheticData()" class="btn-primary">Create data</button>
            </div>

            <div class="card">
                <h3>Available Data</h3>
                <div id="dataOptions"></div>
                <div id="currentDataset" class="status-info">
                    No dataset loaded
                </div>
            </div>
        </section>

        <!-- SECTION 2 : CHECKING -->
        <section id="section-checking" class="section">
            <h2>2. Data checking</h2>

            <div class="card">
                <h3>Dataset Information</h3>
                <div id="checkingDatasetStatus" class="status-info">No dataset loaded</div>
            </div>

            <div class="card">
                <h3>Sample selector</h3>
                <div class="form-group">
                    <label>Sample index (0-based):</label>
                    <input type="number" id="checkSampleIndex" value="0" min="0">
                </div>
                <button onclick="showSamplePlot(document.getElementById('checkSampleIndex').value)" class="btn-primary">Show sample</button>
                <button onclick="showRandomSample()" class="btn-secondary">Random sample</button>
            </div>

            <div class="card">
                <h3>Sample visualization</h3>
                <div id="checkPlotContainer" style="text-align:center;">
                    <img id="checkPlot" src="" alt="Sample plot will appear here" style="max-width:100%; height:auto;"/>
                </div>
            </div>
        </section>

        <!-- SECTION 3 : TRAINING -->
        <section id="section-training" class="section">
            <h2>2. Training the Model</h2>

            <div class="card">
                <h3>Dataset Information</h3>
                <div id="trainingDatasetInfo" class="status-info">
                    No dataset loaded for training
                </div>
            </div>
            
            <div class="card">
                <h3>Training Parameters</h3>
                <div class="form-group">
                    <label>Number of epochs:</label>
                    <input type="number" id="trainingEpochs" value="100" min="10" max="1000">
                </div>
                <div class="form-group">
                    <label>Learning rate:</label>
                    <input type="number" id="learningRate" value="0.001" step="0.0001" min="0.0001" max="0.1">
                </div>
                <div class="form-group">
                    <label>Latent dimension:</label>
                    <input type="number" id="encodingDim" value="8" min="2" max="20">
                </div>
                <button onclick="startTraining()" class="btn-primary" id="startTrainingBtn">Start Training</button>
            </div>
            
            <div class="card">
                <h3>Training Progress</h3>
                <div class="status">
                    <p>Status: <span id="statusText">Waiting...</span></p>
                    <p>Epoch: <span id="epochText">0</span>/<span id="totalEpochs">0</span></p>
                    <p>Current Loss: <span id="lossText">0.0000</span></p>
                </div>
                <div style="position: relative; height:400px; width:100%;">
                    <canvas id="trainingChart"></canvas>
                </div>
                <button onclick="resetTraining()" class="btn-warning">Reset</button>
            </div>
            
            <div class="card">
                <h3>Available Saved Models</h3>
                <div id="modelOptions"></div>
                <button onclick="loadSelectedModel()" class="btn-secondary">Load Selected Model</button>
                <div id="currentModelStatus" class="status-info">
                    No model loaded
                </div>
            </div>
        </section>



        <!-- SECTION 3 : VISUALIZATION -->
        <section id="section-visualization" class="section">
            <h2>3. Latent Space Visualization</h2>

            <div class="card">
                <h3>Dataset Information</h3>
                <div id="visualizationDatasetInfo" class="status-info">
                    No dataset loaded for visualization
                </div>
            </div>
            
            <div class="card">
                <h3>Model Information</h3>
                <div id="visualizationModelInfo" class="status-info">
                    No model loaded for visualization
                </div>
            </div>
            
            <div class="card">
                <h3>2D Projection of Latent Space</h3>
                <button onclick="generateLatentSpace()" class="btn-primary">Generate Visualization</button>
                <div style="position: relative; height:600px; width:100%;">
                    <canvas id="latentSpaceChart"></canvas>
                </div>
                <div id="pointInfo" class="point-info">
                    Hover over the points to see details.
                </div>
                <div class="card">
                    <h4>Sample reconstruction</h4>
                    <div style="position: relative; height:300px; width:100%;">
                        <canvas id="reconstructionChart"></canvas>
                    </div>
                    <div id="reconInfo" class="point-info">
                        Click a point in the latent space to see its reconstruction.
                    </div>
                </div>
            </div>
        </section>

        <!-- SECTION 5 : CLASSIFICATION -->
        <section id="section-classification" class="section">
            <h2>5. Classification</h2>

            <div class="card">
                <h3>Dataset Information</h3>
                <div id="classificationDatasetInfo" class="status-info">No dataset loaded for classification</div>
            </div>

            <div class="card">
                <h3>Model Information</h3>
                <div id="classificationModelInfo" class="status-info">No model loaded for classification</div>
            </div>

            <div class="card">
                <h3>2D Projection (select to label)</h3>
                <button onclick="generateClassificationLatentSpace()" class="btn-primary">Load projection</button>
                <div id="classificationContainer" style="position:relative; height:600px; width:100%;">
                    <canvas id="classificationChart"></canvas>
                    <!-- overlay canvas for drawing selection polygon -->
                    <canvas id="classificationOverlay" style="position:absolute; left:0; top:0; pointer-events:none;"></canvas>
                </div>
                <div id="classificationInfo" class="point-info">Drag to draw a polygon to select points.</div>
            </div>
        </section>
    </div>



    <script>
        const API_BASE = "http://localhost:8000";
        let trainingInterval = null;
        let trainingChart = null;
        let latentSpaceChart = null;
        let reconstructionChart = null;

        // Navigation between sections
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);

                // Update navigation
                document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                
                this.classList.add('active');
                document.getElementById(targetId).classList.add('active');
                // if activating classification section, ensure overlay is synced
                if (targetId === 'section-classification' && classificationChart) {
                    syncOverlayToChart();
                }
            });
        });

        // Initialization
        document.addEventListener('DOMContentLoaded', function() {
            // init functions
            loadDataOptions();
            checkCurrentDataset();
            updateCheckingDatasetStatus();
            loadModelOptions();
            checkCurrentModel();
            initTrainingChart();
            initLatentSpaceChart();
            initReconstructionChart();
            // initialize classification overlay elements when DOM ready
            // actual chart init will happen when user loads projection
            const overlay = document.getElementById('classificationOverlay');
            if (overlay) {
                // size will be set when chart is created
                overlay.style.pointerEvents = 'auto';
            }
        });




        // === FUNCTIONS SECTION 1 : DATA ===

        async function loadDataOptions() {
            try {
                const response = await fetch(`${API_BASE}/data-options`);
                const data = await response.json();
                
                let html = '<h4>Synthetic files:</h4>';
                data.synthetic_files.forEach(file => {
                    html += `<div class="file-item">
                        <input type="radio" name="dataFile" value="${file}" data-type="synthetic">
                        ${file}
                        <button onclick="loadDataset('${file}', 'synthetic')" class="btn-small">Load</button>
                        <button onclick="deleteDataset('${file}', 'synthetic')" class="btn-small">Delete</button>
                    </div>`;
                });
                
                html += '<h4>Uploaded files:</h4>';
                data.uploaded_files.forEach(file => {
                    html += `<div class="file-item">
                        <input type="radio" name="dataFile" value="${file}" data-type="uploaded">
                        ${file}
                        <button onclick="loadDataset('${file}', 'uploaded')" class="btn-small">Load</button>
                        <button onclick="deleteDataset('${file}', 'synthetic')" class="btn-small">Delete</button>
                    </div>`;
                });
                
                document.getElementById('dataOptions').innerHTML = html;
            } catch (error) {
                console.error('Error:', error);
            }
        }
        
        async function loadDataset(filename, dataType) {
            try {
                const response = await fetch(
                    `${API_BASE}/load-dataset?filename=${filename}&data_type=${dataType}`,
                    { method: 'POST' }
                );
                const result = await response.json();
                checkCurrentDataset();
                alert(`Dataset loaded: ${result.filename}`);
            } catch (error) {
                console.error('Error:', error);
                alert('Error loading dataset');
            }
        }
        
        async function deleteDataset(filename, dataType) {
            if (!confirm(`Are you sure you want to delete ${filename}?`)) {
                return;
            }
            try {
                const response = await fetch(
                    `${API_BASE}/delete-dataset?filename=${filename}&data_type=${dataType}`,
                    { method: 'DELETE' }
                );
                const result = await response.json();
                alert(`Dataset deleted: ${result.filename}`);
                loadDataOptions();
                checkCurrentDataset();
            } catch (error) {
                console.error('Error:', error);
                alert('Error deleting dataset');
            }
        }
        
        async function checkCurrentDataset() {
            try {
                const response = await fetch(`${API_BASE}/current-dataset`);
                const data = await response.json();
                
                if (data.loaded) {
                    document.getElementById('checkingDatasetStatus').innerHTML = 
                        `<div class="success">Dataset loaded: ${data.filename} (${data.shape[0]} samples, ${data.shape[1]} features)</div>`;
                    document.getElementById('currentDataset').innerHTML = 
                        `<div class="success">Dataset loaded: ${data.filename} (${data.shape[0]} samples, ${data.shape[1]} features)</div>`;
                    document.getElementById('trainingDatasetInfo').innerHTML = 
                        `<div class="success">Ready for training: ${data.filename} (${data.shape[0]} samples, ${data.shape[1]} features)</div>`;
                    document.getElementById('visualizationDatasetInfo').innerHTML = 
                        `<div class="success">Ready for visualization: ${data.filename} (${data.shape[0]} samples, ${data.shape[1]} features)</div>`;
                    document.getElementById('classificationDatasetInfo').innerHTML = 
                        `<div class="success">Ready for classification: ${data.filename} (${data.shape[0]} samples, ${data.shape[1]} features)</div>`;
                } else {
                    document.getElementById('checkingDatasetStatus').innerHTML = 
                        '<div class="warning">No dataset loaded</div>';
                    document.getElementById('currentDataset').innerHTML = 
                        '<div class="warning">No dataset loaded</div>';
                    document.getElementById('trainingDatasetInfo').innerHTML = 
                        '<div class="warning">No dataset loaded for training</div>';
                    document.getElementById('visualizationDatasetInfo').innerHTML =
                        '<div class="warning">No dataset loaded for visualization</div>';
                    document.getElementById('classificationDatasetInfo').innerHTML =
                        '<div class="warning">No dataset loaded for classification</div>';
                }
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('checkingDatasetStatus').innerHTML = 
                    '<div class="error">Error checking dataset</div>';
                document.getElementById('currentDataset').innerHTML = 
                    '<div class="error">Error checking dataset</div>';
                document.getElementById('trainingDatasetInfo').innerHTML = 
                    '<div class="error">Error checking dataset</div>';
                document.getElementById('visualizationDatasetInfo').innerHTML =
                    '<div class="error">Error checking dataset</div>';
                document.getElementById('classificationDatasetInfo').innerHTML =
                    '<div class="error">Error checking dataset</div>';
            }
        }

        async function createSyntheticData() {
            const nSamples = document.getElementById('nSamples').value;
            const inputDim = document.getElementById('inputDim').value;
            const nAnomalies = document.getElementById('nAnomalies').value;
            
            try {
                const response = await fetch(
                    `${API_BASE}/create-synthetic-data?n_samples=${nSamples}&input_dim=${inputDim}&n_anomalies=${nAnomalies}`,
                    { method: 'POST' }
                );
                const result = await response.json();
                alert(`Created data: ${result.filename}`);
                loadDataOptions();
            } catch (error) {
                console.error('Error:', error);
                alert('Error creating data');
            }
        }

        async function uploadData() {
            const fileInput = document.getElementById('fileUpload');
            if (!fileInput.files[0]) {
                alert('Please select a file to upload');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            
            try {
                const response = await fetch(`${API_BASE}/upload-data`, {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                document.getElementById('uploadStatus').innerHTML = 
                    `<div class="success">Uploaded file: ${result.filename}</div>`;
                loadDataOptions();
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('uploadStatus').innerHTML = 
                    `<div class="error">Error uploading file</div>`;
            }
        }
        


        // === FUNCTIONS SECTION 2 : CHECKING ===

        async function updateCheckingDatasetStatus() {
            try {
                const resp = await fetch(`${API_BASE}/current-dataset`);
                const info = await resp.json();
                const el = document.getElementById('checkingDatasetStatus');
                if (info.loaded) {
                    el.innerHTML = `<div class="success">Dataset loaded: ${info.filename} (${info.shape[0]} samples, ${info.shape[1]} features)</div>`;
                    document.getElementById('checkSampleIndex').max = info.shape[0] - 1;
                } else {
                    el.innerHTML = `<div class="warning">No dataset loaded</div>`;
                }
            } catch (err) {
                console.error('Error checking dataset for checking tab', err);
                const el = document.getElementById('checkingDatasetStatus');
                if (el) el.innerHTML = `<div class="error">Error checking dataset</div>`;
            }
        }

        async function showRandomSample() {
            try {
                const resp = await fetch(`${API_BASE}/current-dataset`);
                const info = await resp.json();
                if (!info.loaded) {
                    alert('No dataset loaded');
                    return;
                }
                const max = info.shape[0] - 1;
                const idx = Math.floor(Math.random() * (max + 1));
                document.getElementById('checkSampleIndex').value = idx;
                await showSamplePlot(idx);
            } catch (err) {
                console.error('Error selecting random sample', err);
            }
        }

        async function showSamplePlot(index) {
            try {
                const idx = parseInt(index);
                if (isNaN(idx)) {
                    alert('Invalid index');
                    return;
                }

                const resp = await fetch(`${API_BASE}/check-sample-plot?index=${idx}`);
                if (!resp.ok) {
                    const err = await resp.json().catch(() => ({}));
                    alert(`Error: ${err.detail || resp.statusText}`);
                    return;
                }

                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                const img = document.getElementById('checkPlot');
                img.src = url;
                img.onload = () => { URL.revokeObjectURL(url); };
            } catch (err) {
                console.error('Error fetching sample plot', err);
                alert('Error fetching sample plot');
            }
        }



        // === FUNCTIONS SECTION 3 : TRAINING ===

        function initTrainingChart() {
            const ctx = document.getElementById('trainingChart').getContext('2d');
            trainingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Training Loss',
                        data: [],
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        borderWidth: 2,
                        pointRadius: 3,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Epoch' } },
                        y: { title: { display: true, text: 'Loss' }, beginAtZero: true }
                    }
                }
            });
        }

        async function loadModelOptions() {
            try {
                const response = await fetch(`${API_BASE}/model-options`);
                const data = await response.json();
                
                let html = '';
                data.saved_models.forEach(model => {
                    html += `<div class="file-item">
                        <input type="radio" name="modelFile" value="${model}">
                        ${model}
                        <button onclick="deleteModel('${model}')" class="btn-small">Delete</button>
                    </div>`;
                });
                
                document.getElementById('modelOptions').innerHTML = html || 'No saved models available.';

            } catch (error) {
                console.error('Error:', error);
            }
        }

        async function deleteModel(modelFilename) {
            if (!confirm(`Are you sure you want to delete model ${modelFilename}?`)) {
                return;
            }
            try {
                const response = await fetch(
                    `${API_BASE}/delete-model?model_filename=${modelFilename}`,
                    { method: 'DELETE' }
                );
                const result = await response.json();
                alert(`Model deleted: ${result.model_filename || modelFilename}`);
                loadModelOptions();
                checkCurrentModel();
            } catch (error) {
                console.error('Error:', error);
                alert('Error deleting model');
            }
        }

        async function checkCurrentModel() {
            try {
                const res = await fetch(`${API_BASE}/current-model`);
                const info = await res.json();
                const currentEl = document.getElementById('currentModelStatus');
                const vizEl = document.getElementById('visualizationModelInfo');
                const classEl = document.getElementById('classificationModelInfo');

                if (info.error) {
                    if (currentEl) currentEl.innerHTML = `<div class="error">Error loading model: ${info.error}</div>`;
                    if (vizEl) vizEl.innerHTML = `<div class="error">Error loading model: ${info.error}</div>`;
                    if (classEl) classEl.innerHTML = `<div class="error">Error loading model: ${info.error}</div>`;
                } else if (info.loaded) {
                    if (currentEl) currentEl.innerHTML = `<div class="success">Model loaded${info.encoding_dim? (': encoding_dim ' + info.encoding_dim) : ''}${info.input_dim? (', input_dim ' + info.input_dim) : ''}</div>`;
                    if (vizEl) vizEl.innerHTML = `<div class="success">Ready for visualization:${info.encoding_dim? (': encoding_dim ' + info.encoding_dim) : ''}</div>`;
                    if (classEl) classEl.innerHTML = `<div class="success">Ready for classification:${info.encoding_dim? (': encoding_dim ' + info.encoding_dim) : ''}</div>`;
                } else {
                    if (currentEl) currentEl.innerHTML = '<div class="warning">No model loaded</div>';
                    if (vizEl) vizEl.innerHTML = '<div class="warning">No model loaded for visualization</div>';
                    if (classEl) classEl.innerHTML = '<div class="warning">No model loaded for classification</div>';
                }

            } catch (error) {
                console.error('Error:', error);
                const currentEl = document.getElementById('currentModelStatus');
                const vizEl = document.getElementById('visualizationModelInfo');
                const classEl = document.getElementById('classificationModelInfo');
                if (currentEl) currentEl.innerHTML = '<div class="error">Error checking model</div>';
                if (vizEl) vizEl.innerHTML = '<div class="error">Error checking model</div>';
                if (classEl) classEl.innerHTML = '<div class="error">Error checking model</div>';
            }
        }

        async function startTraining() {
            const epochs = document.getElementById('trainingEpochs').value;
            const learningRate = document.getElementById('learningRate').value;
            const encodingDim = document.getElementById('encodingDim').value;
            
            try {
                const response = await fetch(
                    `${API_BASE}/start-training?epochs=${epochs}&learning_rate=${learningRate}&encoding_dim=${encodingDim}`,
                    { method: 'POST' }
                );
                const result = await response.json();

                document.getElementById('statusText').textContent = 'Training in progress...';
                document.getElementById('totalEpochs').textContent = result.total_epochs;
                
                startTrainingMonitoring();
                
            } catch (error) {
                console.error('Error:', error);
                alert('Error starting training');
            }
        }

        function startTrainingMonitoring() {
            trainingInterval = setInterval(updateTrainingStatus, 500);
        }

        async function updateTrainingStatus() {
            try {
                const response = await fetch(`${API_BASE}/training-status`);
                const data = await response.json();
                
                document.getElementById('epochText').textContent = data.current_epoch;
                document.getElementById('lossText').textContent = data.current_loss.toFixed(4);

                // Update chart
                if (data.epochs_data && data.loss_data) {
                    trainingChart.data.labels = data.epochs_data;
                    trainingChart.data.datasets[0].data = data.loss_data;
                    trainingChart.update();
                }
                
                if (!data.is_training && data.current_epoch > 0) {
                    document.getElementById('statusText').textContent = 'Training complete';
                    clearInterval(trainingInterval);
                    loadModelOptions(); // Reload model list
                }
                
            } catch (error) {
                console.error('Error:', error);
            }
        }

        async function resetTraining() {
            try {
                await fetch(`${API_BASE}/reset-training`, { method: 'POST' });
                document.getElementById('statusText').textContent = 'Waiting...';
                document.getElementById('epochText').textContent = '0';
                document.getElementById('lossText').textContent = '0.0000';
                trainingChart.data.labels = [];
                trainingChart.data.datasets[0].data = [];
                trainingChart.update();
                clearInterval(trainingInterval);
            } catch (error) {
                console.error('Error:', error);
            }
        }

        async function loadSelectedModel() {
            const selected = document.querySelector('input[name="modelFile"]:checked');
            if (!selected) {
                alert('Please select a model');
                return;
            }
            
            try {
                const response = await fetch(
                    `${API_BASE}/load-model?model_filename=${selected.value}`,
                    { method: 'POST' }
                );
                const result = await response.json();
                alert(`Model loaded: ${result.model_loaded}`);
                // update UI state
                checkCurrentModel();
                loadModelOptions();
            } catch (error) {
                console.error('Error:', error);
                alert('Error loading model');
            }
        }



        // === FUNCTIONS SECTION 4 : VISUALIZATION ===

        function initLatentSpaceChart() {
            const ctx = document.getElementById('latentSpaceChart').getContext('2d');
            latentSpaceChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Normal Points',
                        data: [],
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1,
                        pointRadius: 5
                    }, {
                        label: 'Anomalies',
                        data: [],
                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1,
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'UMAP 1' } },
                        y: { title: { display: true, text: 'UMAP 2' } }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return `Index: ${point.original_index}, Label: ${point.label}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function initReconstructionChart() {
            const ctx = document.getElementById('reconstructionChart').getContext('2d');
            reconstructionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        { label: 'Original', data: [], borderColor: 'rgba(54,162,235,1)', fill: false },
                        { label: 'Reconstruction', data: [], borderColor: 'rgba(255,99,132,1)', fill: false }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Feature index' } },
                        y: { title: { display: true, text: 'Value' } }
                    }
                }
            });
        }

        async function generateLatentSpace() {
            try {
                const response = await fetch(`${API_BASE}/latent-space`);
                const data = await response.json();
                
                const normalPoints = data.points.filter(p => p.label === 0);
                const anomalyPoints = data.points.filter(p => p.label === 1);
                
                latentSpaceChart.data.datasets[0].data = normalPoints;
                latentSpaceChart.data.datasets[1].data = anomalyPoints;
                latentSpaceChart.update();

                // store latent vectors for hover interactions
                window._latent_vectors = data.latent_vectors || [];

                document.getElementById('pointInfo').innerHTML =
                    `${data.points.length} points projected (${anomalyPoints.length} anomalies detected)`;

                // attach mousemove listener to show dynamic coordinates and nearest sample
                const canvas = document.getElementById('latentSpaceChart');
                canvas.onmousemove = function(evt) {
                    const rect = canvas.getBoundingClientRect();
                    const x = evt.clientX - rect.left;
                    const y = evt.clientY - rect.top;

                    const chartArea = latentSpaceChart.chartArea;
                    if (!chartArea) return;

                    // convert pixel coordinates to chart (data) coordinates
                    const xScale = latentSpaceChart.scales['x'];
                    const yScale = latentSpaceChart.scales['y'];
                    if (!xScale || !yScale) return;

                    const px = xScale.getValueForPixel(x);
                    const py = yScale.getValueForPixel(y);

                    // find nearest latent vector in original latent space (not UMAP)
                    let nearestIdx = -1;
                    let nearestDist = Infinity;
                    if (window._latent_vectors && window._latent_vectors.length) {
                        // we need to find the inverse mapping from UMAP to latent - not trivial.
                        // instead, we find nearest in UMAP projection space using original projected points (data.points)
                        const allPoints = data.points;
                        for (let i = 0; i < allPoints.length; i++) {
                            const dx = allPoints[i].x - px;
                            const dy = allPoints[i].y - py;
                            const d = dx*dx + dy*dy;
                            if (d < nearestDist) {
                                nearestDist = d;
                                nearestIdx = allPoints[i].original_index;
                            }
                        }
                    }

                    const latentVec = (window._latent_vectors && nearestIdx >= 0) ? window._latent_vectors[nearestIdx] : null;

                    document.getElementById('pointInfo').innerHTML = 
                        `UMAP: (${px.toFixed(3)}, ${py.toFixed(3)})` +
                        (latentVec ? ` | Latent: [${latentVec.map(v => v.toFixed(4)).slice(0,8).join(', ')}${latentVec.length>8? ', ...':''}]` : '') +
                        (nearestIdx>=0 ? ` | Nearest sample: ${nearestIdx}` : '');
                };

                // click handler: find nearest point and request reconstruction
                canvas.onclick = async function(evt) {
                    try {
                        const rect = canvas.getBoundingClientRect();
                        const x = evt.clientX - rect.left;
                        const y = evt.clientY - rect.top;

                        const xScale = latentSpaceChart.scales['x'];
                        const yScale = latentSpaceChart.scales['y'];
                        if (!xScale || !yScale) return;

                        const px = xScale.getValueForPixel(x);
                        const py = yScale.getValueForPixel(y);

                        // find nearest in projected space
                        let nearestIdx = -1;
                        let nearestDist = Infinity;
                        const allPoints = data.points || [];
                        for (let i = 0; i < allPoints.length; i++) {
                            const dx = allPoints[i].x - px;
                            const dy = allPoints[i].y - py;
                            const d = dx*dx + dy*dy;
                            if (d < nearestDist) {
                                nearestDist = d;
                                nearestIdx = allPoints[i].original_index;
                            }
                        }

                        if (nearestIdx < 0) {
                            document.getElementById('reconInfo').textContent = 'No sample found near click';
                            return;
                        }

                        // fetch reconstruction
                        const resp = await fetch(`${API_BASE}/reconstruct?index=${nearestIdx}`);
                        if (!resp.ok) {
                            const err = await resp.json().catch(() => ({}));
                            document.getElementById('reconInfo').textContent = `Error: ${err.detail || resp.statusText}`;
                            return;
                        }
                        const recData = await resp.json();

                        const original = recData.original || [];
                        const reconstruction = recData.reconstruction || [];

                        // prepare labels
                        const labels = original.map((_, i) => i);

                        // initialize reconstruction chart if needed
                        if (!reconstructionChart) initReconstructionChart();

                        reconstructionChart.data.labels = labels;
                        reconstructionChart.data.datasets[0].data = original;
                        reconstructionChart.data.datasets[1].data = reconstruction;
                        reconstructionChart.update();

                        document.getElementById('reconInfo').textContent = `Index: ${recData.index} | Distance (proj): ${nearestDist.toFixed(4)}`;

                    } catch (err) {
                        console.error('Reconstruction error', err);
                        document.getElementById('reconInfo').textContent = 'Error fetching reconstruction';
                    }
                };

            } catch (error) {
                console.error('Error:', error);
                alert('Error generating latent space');
            }
        }



        // === FUNCTIONS SECTION 5 : CLASSIFICATION ===

        let classificationChart = null;
        let classificationData = null;
        let overlayCanvas = null;
        let overlayCtx = null;
        let isDrawing = false;
        let polygon = [];

        function initClassificationChart() {
            const ctx = document.getElementById('classificationChart').getContext('2d');
            classificationChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [{ label: 'Points', data: [], pointRadius: 4 }] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { x: { title: { display: true, text: 'UMAP 1' } }, y: { title: { display: true, text: 'UMAP 2' } } },
                    plugins: { tooltip: { callbacks: { label: function(context){ const p = context.raw; return `Index: ${p.original_index}, Label: ${p.label}`; } } } }
                }
            });

            // setup overlay (position and size will be synced)
            overlayCanvas = document.getElementById('classificationOverlay');
            overlayCanvas.style.pointerEvents = 'auto';
            overlayCtx = overlayCanvas.getContext('2d');
            // initial sync (handles DPR and CSS sizing)
            syncOverlayToChart();
            // keep overlay in sync on window resize
            window.addEventListener('resize', () => { if (classificationChart) syncOverlayToChart(); });

            // enable drawing
            overlayCanvas.addEventListener('mousedown', (e)=>{
                e.preventDefault();
                isDrawing = true; polygon = [];
                const r = overlayCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const x = (e.clientX - r.left) * (overlayCanvas.width / (r.width * dpr));
                const y = (e.clientY - r.top) * (overlayCanvas.height / (r.height * dpr));
                polygon.push([x,y]); overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
                overlayCtx.beginPath(); overlayCtx.moveTo(x,y);
            });
            overlayCanvas.addEventListener('mousemove', (e)=>{
                if(!isDrawing) return; e.preventDefault(); const r = overlayCanvas.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1; const x = (e.clientX - r.left) * (overlayCanvas.width / (r.width * dpr)); const y = (e.clientY - r.top) * (overlayCanvas.height / (r.height * dpr)); polygon.push([x,y]); overlayCtx.lineTo(x,y); overlayCtx.strokeStyle='rgba(0,0,0,0.6)'; overlayCtx.lineWidth=2; overlayCtx.stroke();
            });
            overlayCanvas.addEventListener('mouseup', async (e)=>{
                if(!isDrawing) return; isDrawing=false; overlayCtx.closePath();
                // compute selected points
                const selected = [];
                const xScale = classificationChart.scales['x']; const yScale = classificationChart.scales['y'];
                if(!xScale || !yScale) return;
                // convert polygon points from overlay pixel space back to chart pixel space (accounting for DPR)
                const r = overlayCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const polyPixels = polygon.map(pt => {
                    const px = pt[0] * (r.width * dpr) / overlayCanvas.width + r.left * dpr;
                    const py = pt[1] * (r.height * dpr) / overlayCanvas.height + r.top * dpr;
                    return [px/dpr - r.left, py/dpr - r.top];
                });
                for(let i=0;i<classificationData.points.length;i++){
                    const p = classificationData.points[i];
                    const px = xScale.getPixelForValue(p.x); const py = yScale.getPixelForValue(p.y);
                    if(pointInPolygon([px,py], polyPixels)) selected.push(i);
                }
                if(selected.length===0){ document.getElementById('classificationInfo').textContent='No points selected.'; return; }
                const newLabel = prompt(`Assign new integer label to ${selected.length} selected points:`, '1');
                if(newLabel===null){ document.getElementById('classificationInfo').textContent='Selection cancelled.'; return; }
                const lab = parseInt(newLabel); if(isNaN(lab)){ alert('Label must be integer'); return; }
                selected.forEach(idx => classificationData.points[idx].label = lab);
                renderClassificationPoints();
                document.getElementById('classificationInfo').textContent = `Assigned label ${lab} to ${selected.length} points.`;
                // clear overlay after selection
                setTimeout(()=>{ overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height); }, 500);
            });
        }

        function pointInPolygon(point, vs){
            const x = point[0], y = point[1]; let inside=false; for(let i=0,j=vs.length-1;i<vs.length;j=i++){
                const xi=vs[i][0], yi=vs[i][1], xj=vs[j][0], yj=vs[j][1]; const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi); if(intersect) inside=!inside;
            } return inside;
        }

        // synchronize overlay canvas size and transform with the Chart.js canvas
        function syncOverlayToChart(){
            if(!classificationChart || !overlayCanvas) return;
            const chartCanvas = classificationChart.canvas;
            const chartRect = chartCanvas.getBoundingClientRect();
            // set CSS size to match chart drawing area
            overlayCanvas.style.left = chartCanvas.offsetLeft + 'px';
            overlayCanvas.style.top = chartCanvas.offsetTop + 'px';
            overlayCanvas.style.width = chartRect.width + 'px';
            overlayCanvas.style.height = chartRect.height + 'px';
            // adjust for devicePixelRatio for crisp drawing
            const dpr = window.devicePixelRatio || 1;
            overlayCanvas.width = Math.round(chartRect.width * dpr);
            overlayCanvas.height = Math.round(chartRect.height * dpr);
            overlayCtx = overlayCanvas.getContext('2d');
            overlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
            // ensure pointer events enabled
            overlayCanvas.style.pointerEvents = 'auto';
        }

        async function generateClassificationLatentSpace(){
            try{
                const resp = await fetch(`${API_BASE}/latent-space`);
                const data = await resp.json();
                classificationData = { points: data.points.map(p=>({x:p.x,y:p.y,label:p.label,original_index:p.original_index})), latent_vectors: data.latent_vectors };
                initClassificationChart(); renderClassificationPoints();
                document.getElementById('classificationDatasetInfo').innerHTML = document.getElementById('visualizationDatasetInfo').innerHTML;
                document.getElementById('classificationModelInfo').innerHTML = document.getElementById('visualizationModelInfo').innerHTML;
            }catch(err){ console.error(err); alert('Error loading classification latent space'); }
        }

        function renderClassificationPoints(){
            if(!classificationChart || !classificationData) return; const palette=['rgba(54,162,235,0.8)','rgba(255,99,132,0.8)','rgba(75,192,192,0.8)','rgba(255,205,86,0.8)','rgba(153,102,255,0.8)','rgba(201,203,207,0.8)']; const colorMap={}; let mapCount=0;
            const ds = classificationData.points.map(p=>{ const lab = p.label||0; if(!(lab in colorMap)){ colorMap[lab]=palette[mapCount%palette.length]; mapCount++; } return {x:p.x,y:p.y,original_index:p.original_index,label:lab, backgroundColor: colorMap[lab]}; });
            classificationChart.data.datasets[0].data = ds; classificationChart.update();
        }
    </script>
</body>
</html>